<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Three.js Fading Grid</title>
  <style>
    body { margin: 0; overflow: hidden; }
    canvas { display: block; }
  </style>
</head>
<body>
  <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>
  <script>
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0xeeeeee);

    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(5, 5, 5);
    camera.lookAt(0, 0, 0);

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    // Custom fading grid using a plane and shader
    const gridSize = 50;
    const gridRes = 100;

    const gridgeometry = new THREE.PlaneGeometry(gridSize, gridSize, gridRes, gridRes);

    const gridmaterial = new THREE.ShaderMaterial({
      transparent: true,
      side: THREE.DoubleSide,
      uniforms: {
        uSize: { value: gridSize }
      },
      vertexShader: `
        varying vec2 vUv;
        void main() {
          vUv = uv - 0.5;
          gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
      `,
      fragmentShader: `
        varying vec2 vUv;
        uniform float uSize;
        void main() {
          float dist = length(vUv) * 2.0; // range [0,1]
          float alpha = smoothstep(1.0, 0.5, dist); // fade from center
          
          float lines = step(0.01, abs(fract(vUv.x * uSize) - 0.5)) *
                        step(0.01, abs(fract(vUv.y * uSize) - 0.5));
          float lineStrength = 1.0 - lines;

          gl_FragColor = vec4(vec3(0.2), alpha * lineStrength);
        }
      `
    });

    const grid = new THREE.Mesh(gridgeometry, gridmaterial);
    grid.rotation.x = -Math.PI / 2;
    grid.position.set(0.5,-0.01,0.5)
    scene.add(grid);

    // X-axis red line
    const xMaterial = new THREE.LineBasicMaterial({ color: 0xff0000 });
    const xGeometry = new THREE.BufferGeometry().setFromPoints([
      new THREE.Vector3(-50, 0, 0),
      new THREE.Vector3(50, 0, 0),
    ]);
    const xLine = new THREE.Line(xGeometry, xMaterial);
    scene.add(xLine);

    // Y-axis green line
    const yMaterial = new THREE.LineBasicMaterial({ color: 0x00ff00 });
    const yGeometry = new THREE.BufferGeometry().setFromPoints([
      new THREE.Vector3(0, 0, -50),
      new THREE.Vector3(0, 0, 50),
    ]);
    const yLine = new THREE.Line(yGeometry, yMaterial);
    scene.add(yLine);

    // Light
/*     const light = new THREE.DirectionalLight(0xffffff, 1);
    light.position.set(5, 10, 7.5);
    scene.add(light); */

    // Animate
    function animate() {
      requestAnimationFrame(animate);
      renderer.render(scene, camera);
    }
    animate();

    // Resize
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
  </script>
</body>
</html>